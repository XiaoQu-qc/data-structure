### 1.数组的初始容量为16， 也可以指定容量，但必须为2的整数倍
原因：key在数组中位置计算方式：hashcode&（capacity-1），如果容量是2的整数倍那么&后面的2进制是n个1，这样会使index比较平均
在 HashMap 中，哈希碰撞（Hash Collision） 是指两个或多个不同的键（key）通过哈希函数计算后，得到相同的哈希值，导致这些键被映射到哈希表中的同一个位置（即同一个桶/数组索引）。
### 2.如果是new HashMap(10)<>,带参构造函数指定数组的初始容量为10，不是2的整数倍
解决方法，创建数组的初始容量并不是10，而是比10大的最小的2的整数倍
n = n-1
n |= n>>1
n |= n>>2
n |= n>>4
n |= n>>8
n |= n>>16
n=n+1
### 3.负载因子
区分负载因子和实时负载因子，负载因子是Hashmap类的成员变量，创建时就被赋值默认是0.75f，实时负载因子=size/capacity，但是实时负载因子是无法超过负载因子的，因为一旦添加某个节点后size>capacity*loadfactor,capacity就要扩容（翻倍）
### 4.有关扩容
扩容是非常耗时间的，相当于把所有的键值对重新hash，重新插入扩容后的数组，因此在实际开发过程中，尽量避免扩容。比如当你知道大概要存放多少个数据时，new一个capacity大小足够大的hashmap
扩容和链表转红黑树的目的时防止同一个桶中的键值对数量过多（链表过长），影响性能
负载因子不能太小，如果太小，那么size很小的时候就要扩容，数组里还没有存放几个键值对就要扩容，扩容太频繁
负载因子也不能太大，太大的话，可能链表已经过长了，影响crud性能，此时扩容又不及时
### 5.hash值如何计算
由源码可知，hash值h = key.hashCode(),hash = h ^ (h>>16),index = hash & (capacity-1)
为什么hash值不直接用key.hashCode呢,这是为了防止两个hash值低位基本相同，而高位有区别时，此时计算出来的index值相同导致碰撞
  1111 1111 1111 1111 1111 0000 1110 1010                   1001 1001 0000 1111 1111 0000 1110 1010
& 0000 0000 0000 0000 0000 0000 0000 1111 capacity-1      & 0000 0000 0000 0000 0000 0000 0000 1111 capacity-1
  0000 0000 0000 0000 0000 0000 0000 1010                   0000 0000 0000 0000 0000 0000 0000 1010
  ### 6.扩容和转成红黑树
  当某个slot处链表太长，调用treeifyBin方法，处理扩容逻辑：如果capacity<64(hashmap类的一个常量)，执行扩容但不执行转成红黑树，也就是说只有当链表过长并且capacity达标的时候才转成红黑树
  同时这里也是第二个可能导致Node数组扩容的地方
