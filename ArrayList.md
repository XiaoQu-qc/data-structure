### 1.clone方法
ArrayList实现cloneable接口并且其clone方法调用Object的clone方法，这个方法是个本地方法，由c语言结合操作系统进行实现
### 2.深克隆
用序列化实现深克隆的原理是：先将对象序列化为字节流，再从字节流中反序列化出一个新的对象。由于反序列化时会重新分配内存空间，因此新对象与原对象在内存中完全独立，实现了深克隆
所有需要序列化的类都必须实现Serializable接口，包括对象及其引用类型的成员变量类。
静态成员和transient修饰的成员不会被序列化，如果需要克隆这些成员，需要额外处理。
序列化和反序列化过程可能会抛出异常，需要进行异常处理

### 3.线程安全
ArrayList不是线程安全的，因为其add，remove方法都没有加锁，可以想象，多个线程同时使用同一个al实例的add方法时，如果对同一个位置进行冲突必然导致逻辑上错误，但是程序不报错
一个线程的修改无法及时反馈到另一个线程中，则是不同步的（不安全），要使用sycroniczed关键字阻塞方法的调用
不是共享的数据不用加锁（线程中的独立变量不用加，共享的全局变量同一个实体类要加），仅查找不用加，增删才要加
